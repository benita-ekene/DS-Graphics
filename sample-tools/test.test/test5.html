<!DOCTYPE html>
<html>
<head>
  <title>Sorting Algorithms Visualization</title>
</head>
<body>
  <input type="file" id="fileInput">
  <label for="algorithm">Algorithm:</label>
  <select id="algorithm">
    <option value="bubble">Bubble Sort</option>
    <option value="insertion">Insertion Sort</option>
    <option value="selection">Selection Sort</option>
    <option value="merge">Merge Sort</option>
    <option value="quick">Quick Sort</option>
  </select>
  <label for="order">Order:</label>
  <select id="order">
    <option value="ascending">Ascending</option>
    <option value="descending">Descending</option>
  </select>
  <button onclick="performSorting()">Start Sorting</button>
  <button onclick="repeatPrevious()">Repeat Previous</button>
  <canvas id="myCanvas" width="800" height="400" style="border: 1px solid black;"></canvas>
  <div id="variablesBefore"></div>
  <div id="variablesAfter"></div>
  <div id="timer"></div>
  <script>
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');
    const barSpacing = 2;
    const canvasHeight = canvas.height;
    const canvasWidth = canvas.width;
    let values = [];
    let sortedValues = [];
    let startTime = 0;
    let timerInterval;

    function parseCSV(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const lines = reader.result.split('\n');
          values = lines.map((line) => parseInt(line.trim()));
          resolve();
        };
        reader.onerror = reject;
        reader.readAsText(file);
      });
    }

    function drawBars() {
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      const barWidth = (canvasWidth - (barSpacing * (values.length - 1))) / values.length;
      for (let i = 0; i < values.length; i++) {
        ctx.fillRect(i * (barWidth + barSpacing), canvasHeight - values[i], barWidth, values[i]);
      }
    }

    function updateTimer() {
      const currentTime = new Date().getTime();
      const elapsedTime = (currentTime - startTime) / 1000;
      document.getElementById('timer').innerText = `Elapsed Time: ${elapsedTime.toFixed(2)} seconds`;
    }

    async function animateSorting(sortingFunction) {
      for (let i = 0; i < values.length; i++) {
        await sortingFunction(i);
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    }

    async function bubbleSort() {
      await animateSorting(async (i) => {
        if (values[i] > values[i + 1]) {
          let temp = values[i];
          values[i] = values[i + 1];
          values[i + 1] = temp;
          drawBars();
        }
      });
    }

    async function insertionSort() {
      await animateSorting(async (i) => {
        let key = values[i];
        let j = i - 1;
        while (j >= 0 && values[j] > key) {
          values[j + 1] = values[j];
          j = j - 1;
        }
        values[j + 1] = key;
        drawBars();
      });
    }

    async function selectionSort() {
      await animateSorting(async (i) => {
        let minIndex = i;
        for (let j = i + 1; j < values.length; j++) {
          if (values[j] < values[minIndex]) {
            minIndex = j;
          }
        }
        if (minIndex !== i) {
          let temp = values[i];
          values[i] = values[minIndex];
          values[minIndex] = temp;
          drawBars();
        }
      });
    }

    async function mergeSort(arr) {
      if (arr.length <= 1) return arr;

      const middle = Math.floor(arr.length / 2);
      const left = arr.slice(0, middle);
      const right = arr.slice(middle);

      return await animateMerge(await mergeSort(left), await mergeSort(right));
    }

    async function animateMerge(left, right) {
      let result = [];
      let leftIndex = 0;
      let rightIndex = 0;

      while (leftIndex < left.length && rightIndex < right.length) {
        if (left[leftIndex] < right[rightIndex]) {
          result.push(left[leftIndex]);
          leftIndex++;
        } else {
          result.push(right[rightIndex]);
          rightIndex++;
        }
      }

      const remaining = left.slice(leftIndex).concat(right.slice(rightIndex));
      result = result.concat(remaining);

      for (let i = 0; i < result.length; i++) {
        values[i] = result[i];
        drawBars();
        await new Promise((resolve) => setTimeout(resolve, 100));
      }

      return result;
    }

    async function quickSort(arr, start, end) {
      if (start >= end) return;

      const index = await partition(arr, start, end);
      await quickSort(arr, start, index - 1);
      await quickSort(arr, index + 1, end);
    }

    async function partition(arr, start, end) {
      let pivotValue = arr[end];
      let pivotIndex = start;
      for (let i = start; i < end; i++) {
        if (arr[i] < pivotValue) {
          await swap(arr, i, pivotIndex);
          pivotIndex++;
        }
      }
      await swap(arr, pivotIndex, end);
      drawBars();
      await new Promise((resolve) => setTimeout(resolve, 100));
      return pivotIndex;
    }

    async function swap(arr, i, j) {
      let temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
    }

    async function performSorting() {
      const algorithm = document.getElementById('algorithm').value;
      const order = document.getElementById('order').value;

      const fileInput = document.getElementById('fileInput');
      if (fileInput.files.length > 0) {
        await parseCSV(fileInput.files[0]);
        document.getElementById('variablesBefore').innerText = `Before sorting: ${values.join(', ')}`;
      } else {
        alert('Please select a CSV file.');
        return;
      }

      drawBars();
      document.getElementById('variablesAfter').innerText = '';

      startTime = new Date().getTime(); // Record the start time for the timer

      switch (algorithm) {
        case 'bubble':
          await bubbleSort();
          break;
        case 'insertion':
          await insertionSort();
          break;
        case 'selection':
          await selectionSort();
          break;
        case 'merge':
          values = await mergeSort(values);
          break;
        case 'quick':
          await quickSort(values, 0, values.length - 1);
          break;
        default:
          break;
      }

      if (order === 'descending') {
        values.reverse();
      }

      sortedValues = values.slice(); // Save the sorted values for repeating
      document.getElementById('variablesAfter').innerText = `After sorting: ${values.join(', ')}`;
      drawBars();

      clearInterval(timerInterval); // Clear any existing timer interval
      updateTimer(); // Show the final time after sorting is completed
    }

    function repeatPrevious() {
      values = sortedValues.slice(); // Restore the original unsorted values
      drawBars();
    }
  </script>
</body>
</html>
