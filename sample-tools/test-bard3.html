<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="algorithm.css">
  <link rel="shortcut icon" href="favicon.ico"/>
  <title>Sorting Algorithms Visualization</title>
</head>
<body>
  <input type="file" id="fileInput">
  <label for="algorithm">Algorithm:</label>
  <select id="algorithm">
    <option value="bubble">Bubble Sort</option>
    <option value="insertion">Insertion Sort</option>
    <option value="selection">Selection Sort</option>
    <option value="merge">Merge Sort</option>
    <option value="quick">Quick Sort</option>
  </select>
  <label for="order">Order:</label>
  <select id="order">
    <option value="ascending">Ascending</option>
    <option value="descending">Descending</option>
  </select>
  <button onclick="performSorting()">Start Sorting</button>
  <button onclick="pauseSorting()">Pause Sorting</button>
  <button onclick="repeatPrevious()">Repeat Previous</button>
  
  <!-- New Input Section -->
  <div>
    <label for="smallData">Enter a list of numbers (comma-separated):</label>
    <input type="text" id="smallData" placeholder="e.g., 5, 2, 10, 1, 7">
  </div>
  
  <canvas id="myCanvas" width="800" height="400" style="border: 1px solid black;"></canvas>
  <div id="timer"></div>
  <div id="variablesWrapper">
    <div id="variablesBefore"></div>
    <div id="variablesAfter"></div>
  </div>
 
  <script>
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');
    const barSpacing = 2;
    const canvasHeight = canvas.height;
    const canvasWidth = canvas.width;
    let values = [];
    let sortedValues = [];
    let startTime = 0;
    let timerInterval;
    let isSortingPaused = false;

    function parseCSV(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const lines = reader.result.split('\n');
          values = lines.map((line) => parseInt(line.trim()));
          resolve();
        };
        reader.onerror = reject;
        reader.readAsText(file);
      });
    }

    function parseSmallData() {
      const dataInput = document.getElementById('smallData');
      if (dataInput.value) {
        values = dataInput.value.split(',').map((val) => parseInt(val.trim()));
        document.getElementById('variablesBefore').innerText = `Before sorting:\n${values.join('\n')}`;
      } else {
        alert('Please enter a list of numbers.');
      }
    }

    function drawBars(swappingIndices = []) {
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      const barWidth = (canvasWidth - (barSpacing * (values.length - 1))) / values.length;
      for (let i = 0; i < values.length; i++) {
        const barHeight = canvasHeight - values[i];
        if (swappingIndices.includes(i)) {
          ctx.fillStyle = 'red'; // Set a different color for swapping elements
        } else {
          ctx.fillStyle = 'blue'; // Default color for other elements
        }
        ctx.fillRect(i * (barWidth + barSpacing), barHeight, barWidth, values[i]);
      }
    }

    function updateTimer() {
      const currentTime = new Date().getTime();
      const elapsedTime = (currentTime - startTime) / 1000;
      document.getElementById('timer').innerText = `Elapsed Time: ${elapsedTime.toFixed(2)} seconds`;
    }

    async function animateSorting(sortingFunction) {
      for (let i = 0; i < values.length; i++) {
        while (isSortingPaused) {
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
        await sortingFunction(i);
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    }

    async function bubbleSort() {
      for (let i = 0; i < values.length - 1; i++) {
        let swapped = false;
        for (let j = 0; j < values.length - i - 1; j++) {
          if (values[j] > values[j + 1]) {
            await swap(values, j, j + 1);
            swapped = true;
            drawBars([j, j + 1]); // Highlight swapping elements in red
          }
        }
        if (!swapped) {
          break; // If no elements were swapped, the array is already sorted
        }
      }
    }

    async function insertionSort() {
      await animateSorting(async (i) => {
        let key = values[i];
        let j = i - 1;
        while (j >= 0 && values[j] > key) {
          await swap(values, j, j + 1);
          drawBars([j, j + 1]); // Highlight swapping elements in red
          j = j - 1;
        }
      });
    }

    async function selectionSort() {
      await animateSorting(async (i) => {
        let minIndex = i;
        for (let j = i + 1; j < values.length; j++) {
          if (values[j] < values[minIndex]) {
            minIndex = j;
          }
        }
        if (minIndex !== i) {
          await swap(values, i, minIndex);
          drawBars([i, minIndex]); // Highlight swapping elements in red
        }
      });
    }

    async function mergeSort(arr) {
      if (arr.length <= 1) return arr;

      const middle = Math.floor(arr.length / 2);
      const left = arr.slice(0, middle);
      const right = arr.slice(middle);

      return await animateMerge(await mergeSort(left), await mergeSort(right));
    }

    async function animateMerge(left, right) {
      let result = [];
      let leftIndex = 0;
      let rightIndex = 0;

      while (leftIndex < left.length && rightIndex < right.length) {
        if (left[leftIndex] < right[rightIndex]) {
          result.push(left[leftIndex]);
          leftIndex++;
        } else {
          result.push(right[rightIndex]);
          rightIndex++;
        }
      }

      const remaining = left.slice(leftIndex).concat(right.slice(rightIndex));
      result = result.concat(remaining);

      for (let i = 0; i < result.length; i++) {
        values[i] = result[i];
        await new Promise((resolve) => setTimeout(() => {
          drawBars(); // Show the merge process without highlighting
          resolve();
        }, 100));
      }

      return result;
    }

    async function quickSort(arr, start, end) {
      if (start >= end) return;

      const index = await partition(arr, start, end);
      await quickSort(arr, start, index - 1);
      await quickSort(arr, index + 1, end);
    }

    async function partition(arr, start, end) {
      let pivotValue = arr[end];
      let pivotIndex = start;
      for (let i = start; i < end; i++) {
        if (arr[i] < pivotValue) {
          await swap(arr, i, pivotIndex);
          drawBars([i, pivotIndex]); // Highlight swapping elements in red
          pivotIndex++;
        }
      }
      await swap(arr, pivotIndex, end);
      drawBars([pivotIndex, end]); // Highlight swapping elements in red
      return pivotIndex;
    }

    async function swap(arr, i, j) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      let temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
      drawBars([i, j]); // Highlight swapping elements in red
    }

    async function performSorting() {
      const algorithm = document.getElementById('algorithm').value;
      const order = document.getElementById('order').value;

      const fileInput = document.getElementById('fileInput');
      if (fileInput.files.length > 0) {
        await parseCSV(fileInput.files[0]);
        document.getElementById('variablesBefore').innerText = `Before sorting:\n${values.join('\n')}`;
      } else {
        parseSmallData();
      }

      drawBars();
      document.getElementById('variablesAfter').innerText = '';

      startTime = new Date().getTime(); // Record the start time for the timer
      isSortingPaused = false; // Reset the sorting paused flag

      switch (algorithm) {
        case 'bubble':
          await bubbleSort();
          break;
        case 'insertion':
          await insertionSort();
          break;
        case 'selection':
          await selectionSort();
          break;
        case 'merge':
          values = await mergeSort(values);
          break;
        case 'quick':
          await quickSort(values, 0, values.length - 1);
          break;
        default:
          break;
      }

      if (order === 'descending') {
        values.reverse();
      }

      sortedValues = values.slice(); // Save the sorted values for repeating
      document.getElementById('variablesAfter').innerText = `After sorting:\n${values.join('\n')}`;
      drawBars();

      clearInterval(timerInterval); // Clear any existing timer interval
      updateTimer(); // Show the final time after sorting is completed
    }

    function repeatPrevious() {
      values = sortedValues.slice(); // Restore the original unsorted values
      drawBars();
    }

    function pauseSorting() {
      isSortingPaused = !isSortingPaused;
    }
  </script>
</body>
</html>
